@* TicketDetails*@
@page "/tickets/{Id:int}"
@attribute [Authorize]

@inject ITicketDTOService TicketService
@inject IProjectDTOService ProjectService
@inject ICompanyDTOService CompanyService
@inject IndexTrackerHelper IndexTracker
@inject NavigationManager NavManager
@inject ISnackbar Snackbar

@inherits AuthenticatedComponentBase

<MudContainer MaxWidth="MaxWidth.Large" Class="py-4 page-container" Style="height: 100%; position: relative">
	<MudBreadcrumbs Items="breadcrumbs" Class="breadcrumbs1" />
	@if (!_loadingComplete)
	{
		<LoadingSpinner Message="Loading project details..." Color="Color.Primary" Size="Size.Large" />
	}
	else if (ticket is not null)
	{
		@* Reset Index at start of render;
						controls the index for components that use IndexTracker.*@
		ResetIndex();
		<PageTitle>@ticket?.Title Details | Dev Tracker</PageTitle>

		<div class="vstack gap-3">

			<TicketGeneralInfo Ticket="ticket"
							   Index="@IndexTracker.Next()" />

			<MudGrid Class="mt-2">
				<MudItem xs="12" md="6">
					<LabeledCard Index="@IndexTracker.Next()" Title="Submitted By:">
						<ProjectTeamCard User="ticket.SubmitterUser"
										 PlaceholderName="Unassigned"
										 PlaceholderRole="@Role.ProjectManager.GetDisplayName()" />
					</LabeledCard>
				</MudItem>

				<MudItem xs="12" md="6">
					<LabeledCard Index="@IndexTracker.Next()"
								 Title="Assigned To:">
						@* <MudIconButton Icon="@Icons.Material.Filled.Edit"
									   ariaLabel="Change assignee" /> *@

						<ProjectTeamCard User="ticket.DeveloperUser"
										 PlaceholderName="Unassigned"
										 PlaceholderRole="@Role.Developer.GetDisplayName()" />
					</LabeledCard>
				</MudItem>
			</MudGrid>

			<!-- Priority, Status & Type components -->
			<TicketMetaRow Index="@IndexTracker.Next()"
						   Priority="@ticket.Priority"
						   Status="@ticket.Status"
						   Type="@ticket.Type" />

			<DescriptionCard Title="Description"
							 Index="@IndexTracker.Next()"
							 Text="@ticket.Description" />

			@* <TicketComments Ticket="ticket"
							Index="@IndexTracker.Next()" /> *@

			@*  <-- <TicketAttachments Ticket="ticket" Index="@IndexTracker.Next()" /> -->
			<TicketHistory Ticket="ticket"
						   Index="@IndexTracker.Next()" />  *@
		</div>
		<div class="d-flex mt-2">
			<BackToBtn Href=@($"/projects/{ticket.ProjectId}") Text="Back to Project" Disabled="@(ticket is null)" />
			@if (_userCanEditTicket)
			{
				<div class="ms-auto">
					<MudButton Variant="Variant.Text"
							   StartIcon="@Icons.Material.Filled.Edit"
							   Href="@($"tickets/{TicketId}/edit")"
							   Disabled="@(ticket is null)"
							   Color="Color.Tertiary">
						Edit
					</MudButton>

					<ArchiveBar IsArchived="ticket!.Archived"
								UserCanArchiveAndRestore="_userCanArchiveTicket"
								ItemLabel="Ticket"
								Busy="@_processingArchiveRestore" />
				</div>

								@* OnArchiveRequested="HandleArchiveAsync"
								OnRestoreRequested="HandleRestoreAsync" *@ 
			}
		</div>
	}
	else
	{
		<PageTitle>Ticket Not Found | Dev Tracker</PageTitle>

		<NotFoundFull Message="Ticket not found"
					  ReturnUrl="/tickets/open"
					  ReturnLabel="Back to Tickets"
					  ForwardUrl="/tickets/create"
					  ForwardLabel="Create New Ticket" />

	}
</MudContainer>

@code {
	[Parameter]
	public int Id { get; set; }
	[Parameter]
	public int TicketId { get; set; }

	private ProjectDTO? project;

	private TicketDTO? ticket;
	private List<BreadcrumbItem> breadcrumbs = [];
	private bool _loadingComplete = false;
	private bool _userCanEditTicket = false;
	private bool _userCanArchiveTicket = false;
	private bool _processingArchiveRestore = false;

	private void ResetIndex() => IndexTracker.Reset();

	// Refresh ProjectMembers component when there is a change to project Manager assignment.
	private Guid _membersRefreshToken = Guid.NewGuid();

	private IReadOnlyList<AppUserDTO> projectManagers = Array.Empty<AppUserDTO>();

	protected override async Task OnParametersSetAsync()
	{
		_loadingComplete = false;
		ticket = null;
		project = null;
		_userCanEditTicket = false;
		try
		{
			ticket = await TicketService.GetTicketByIdAsync(Id, UserInfo!);
			if (ticket is not null)
			{
				breadcrumbs = [new BreadcrumbItem("Home", href: "/")];
				if (ticket.Project is null)
				{
					breadcrumbs.Add(new BreadcrumbItem("Tickets", href: "/tickets/open"));
					if (ticket.Archived) breadcrumbs.Add(new BreadcrumbItem("Archived Tickets", href: "/tickets/archived"));

				}
				else
				{
					breadcrumbs.Add(new BreadcrumbItem("Projects", href: "/projects"));
					breadcrumbs.Add(new BreadcrumbItem(ticket.Project.Name ?? "Unknown Project", href: $"/projects/{ticket.Project.Id}"));
				}
				breadcrumbs.Add(new BreadcrumbItem(ticket.Title ?? "Ticket Not Found", href: null, disabled: true));

				AppUserDTO? pm = await ProjectService.GetProjectManagerAsync(ticket.ProjectId, UserInfo!);
				_userCanEditTicket = (ticket.SubmitterUserId == UserInfo?.UserId) ||
									 (ticket.DeveloperUserId == UserInfo?.UserId) ||
				                     (UserInfo?.IsInRole(Role.Admin) ?? false) ||
				                     (pm?.Id == UserInfo?.UserId);
			}


		}
		catch (Exception ex)
		{
			Console.WriteLine(ex);
			Snackbar.Add("Error loading ticket details.", Severity.Error);
		}

		
		_loadingComplete = true;
		StateHasChanged();

		if (ticket is null) NavManager.NavigateTo("tickets/open");

	}

	// private async Task HandleArchiveAsync()
	// {
	// 	if (_userCanEditProject == false || project is null) return;

	// 	var projectName = project.Name ?? "Project"; // Cache the name

	// 	try
	// 	{
	// 		_processingArchiveRestore = true;
	// 		//archive project
	// 		await ProjectService.ArchiveProjectAsync(project.Id, UserInfo!);

	// 		// //refresh project details to show archived status
	// 		project = await ProjectService.GetProjectByIdAsync(ProjectId, UserInfo!);

	// 		if (project != null) project.Archived = true;


	// 		await InvokeAsync(() => Snackbar.Add($"The Project, '{projectName}' has been archived", Severity.Success));

	// 		// Navigate back to projects list
	// 		NavManager.NavigateTo("/projects");
	// 	}
	// 	catch (Exception ex)
	// 	{

	// 		Console.WriteLine(ex);
	// 		Snackbar.Add($"{projectName} is not available to be archived");
	// 	}
	// 	finally
	// 	{
	// 		_processingArchiveRestore = false;
	// 		StateHasChanged();
	// 	}
	// }

	// private async Task HandleRestoreAsync()
	// {
	// 	if (project is null) return;
	// 	try
	// 	{
	// 		_processingArchiveRestore = true;

	// 		string projectName = project.Name ?? "Project";

	// 		//restore project
	// 		await ProjectService.RestoreProjectByIdAsync(project.Id, UserInfo!);

	// 		//refresh project details to show restored status
	// 		project = await ProjectService.GetProjectByIdAsync(ProjectId, UserInfo!);

	// 		if (project != null) project.Archived = false;

	// 		Snackbar.Add($"The Project '{projectName}' has been restored", Severity.Success);
	// 		// Navigate back to projects list
	// 		NavManager.NavigateTo("/projects");

	// 		if (project == null)
	// 		{
	// 			Snackbar.Add("The project could not be found after restoring.", Severity.Error);
	// 			return;
	// 		}
	// 	}
	// 	catch (Exception ex)
	// 	{
	// 		Console.WriteLine(ex);
	// 		Snackbar.Add($"The Project is not available to be restored");
	// 	}
	// 	finally
	// 	{
	// 		_processingArchiveRestore = false;
	// 		StateHasChanged();
	// 	}
	// }

	// private async Task HandleSavePMAsync(string? newPMId)
	// {
	// 	if (project is null) return;

	// 	try
	// 	{
	// 		if (string.IsNullOrWhiteSpace(newPMId))
	// 		{
	// 			await ProjectService.RemoveProjectManagerAsync(ProjectId, UserInfo!);
	// 		}
	// 		else
	// 		{
	// 			await ProjectService.AssignProjectManagerAsync(ProjectId, newPMId, UserInfo!);
	// 		}

	// 		// Refetch authoritative DTO (ProjectManagerId already populated)
	// 		project = await ProjectService.GetProjectByIdAsync(ProjectId, UserInfo!);

	// 		_membersRefreshToken = Guid.NewGuid();

	// 		Snackbar.Add("Project Manager updated.", Severity.Success);
	// 		StateHasChanged();
	// 	}
	// 	catch (Exception ex)
	// 	{

	// 		Console.WriteLine(ex);

	// 		await InvokeAsync(() => Snackbar.Add("Unable to update Project Manager.", Severity.Error));
	// 	}


	// }


}
